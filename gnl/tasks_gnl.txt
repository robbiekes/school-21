Task 0. Прочитать про static переменные в функциях в Си. 
Отработка знаний о static:
Task 1.
	Написать функцию int ft_putstr(char *str);
	которая печатает строку str. 
	Возвращает количество вызовов этой функции.
	examples:
	ft_putstr("123"); // напечатает 123, возвращаемое значение 1
	ft_putstr("321"); // напечатает 321, возвращаемое значение 2
	ft_putstr("123"); // напечатает 123, возвращаемое значение 3
Task 2.
	Написать функцию int ft_putstr_fd(int fd, char *str);
	которая печатает строку str в файловый поток,
	дескриптор которого fd. Возвращает количество вызовов функций
	для конкретного файла.
	examples:
	ft_putstr(1, "123"); // напечатает 123, возвращаемое значение 1
	ft_putstr(1, "123"); // напечатает 123, возвращаемое значение 2
	ft_putstr(2, "123"); // напечатает 123, возвращаемое значение 1
	ft_putstr(1, "123"); // напечатает 123, возвращаемое значение 3
	ft_putstr(2, "123"); // напечатает 123, возвращаемое значение 2
	ft_putstr(1, "123"); // напечатает 123, возвращаемое значение 4
get_next_line:
	Task 3.
	Написать функцию char * notoptimal_get_next_line(int fd);
	которая считывает из файла следующую строку,
	и возвращает ее копию (вместе c \n). 
	Если произошла ошибка или достигли конца
	файла, возвращает NULL (самая последняя строка может не заканчиваться
	на \n, функция должна вернуть эту строку, а не NULL).
	САМОЕ ВАЖНОЕ: пишем функцию с посимвольным чтением файла (read(fd, buf, 1));
	Task 4.
	Написать функцию int ft_read_one_ch(int fd, char *ch_ptr);
	которая считывает из файла один символ и сохраняет его
	по указателю ch_ptr. Возвращает 1, если смог считать символ,
	0, если достигли конца файла, -1 если ошибка.
	ВАЖНО: Считывание из файла поблочное. (read(fd, buf, BUFFER_SIZE));
	Task 5.
	Написать функцию char * get_next_line(int fd);
	Взять функцию notoptimal_get_next_line и заменить все read(fd, buf, 1)
	на вызов функции ft_read_one_ch. Вы великолепны.
